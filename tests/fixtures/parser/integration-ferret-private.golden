Project
  [ Project
      [ Unit
          [ FunctionDeclaration
              { functionBang = True
              , functionName = "s:delete"
              , functionArguments =
                  ArgumentList [ Argument "first" , Argument "last" ]
              , functionAttributes = []
              , functionBody =
                  [ LetStatement { letLexpr = "l:list" , letValue = "getqflist()" }
                  , LetStatement { letLexpr = "l:line" , letValue = "a:first" }
                  , GenericStatement "while l:line >= a:first && l:line <= a:last"
                  , LetStatement { letLexpr = "l:list[l:line - 1]" , letValue = "0" }
                  , LetStatement { letLexpr = "l:line" , letValue = "l:line + 1" }
                  , GenericStatement "endwhile"
                  , GenericStatement "call setqflist(l:list, 'r')"
                  , GenericStatement "execute 'cc ' . a:first"
                  , GenericStatement "execute \"normal \\<C-W>\\<C-P>\""
                  ]
              }
          , FunctionDeclaration
              { functionBang = True
              , functionName = "s:dispatch"
              , functionArguments = ArgumentList []
              , functionAttributes = []
              , functionBody =
                  [ Empty
                  , LetStatement
                      { letLexpr = "l:dispatch"
                      , letValue = "get(g:, 'FerretDispatch', 1)"
                      }
                  , GenericStatement "return l:dispatch && exists(':Make') == 2"
                  ]
              }
          , FunctionDeclaration
              { functionBang = True
              , functionName = "s:error"
              , functionArguments = ArgumentList [ Argument "message" ]
              , functionAttributes = [ "abort" ]
              , functionBody =
                  [ GenericStatement "call inputsave()"
                  , GenericStatement "echohl ErrorMsg"
                  , GenericStatement
                      "call input(a:message . ': press ENTER to continue')"
                  , GenericStatement "echohl NONE"
                  , GenericStatement "call inputrestore()"
                  , GenericStatement "echo"
                  ]
              }
          , FunctionDeclaration
              { functionBang = True
              , functionName = "s:parse"
              , functionArguments = ArgumentList [ Argument "arg" ]
              , functionAttributes = [ "abort" ]
              , functionBody =
                  [ GenericStatement "if exists('g:ferret_lastsearch')"
                  , UnletStatement
                      { unletBang = False , unletBody = "g:ferret_lastsearch" }
                  , GenericStatement "endif"
                  , LetStatement
                      { letLexpr = "l:escaped_spaces_replaced_with_markers"
                      , letValue = "substitute(a:arg, '\\\\ ', '<!!S!!>', 'g')"
                      }
                  , LetStatement
                      { letLexpr = "l:split_on_spaces"
                      , letValue = "split(l:escaped_spaces_replaced_with_markers)"
                      }
                  , LetStatement { letLexpr = "l:expanded_args" , letValue = "[]" }
                  , GenericStatement "for l:arg in l:split_on_spaces"
                  , GenericStatement "if l:arg =~# '^-'"
                  , GenericStatement "call add(l:expanded_args, l:arg)"
                  , GenericStatement "elseif exists('g:ferret_lastsearch')"
                  , LetStatement
                      { letLexpr = "l:file_args"
                      , letValue =
                          "glob(l:arg, 1, 1) \" Ignore 'wildignore', return a list."
                      }
                  , GenericStatement "if len(l:file_args)"
                  , GenericStatement "call extend(l:expanded_args, l:file_args)"
                  , GenericStatement "else"
                  , GenericStatement "call add(l:expanded_args, l:arg)"
                  , GenericStatement "endif"
                  , GenericStatement "else"
                  , LetStatement
                      { letLexpr = "g:ferret_lastsearch"
                      , letValue = "substitute(l:arg, '<!!S!!>', ' ', 'g')"
                      }
                  , GenericStatement "call add(l:expanded_args, l:arg)"
                  , GenericStatement "endif"
                  , GenericStatement "endfor"
                  , LetStatement
                      { letLexpr = "l:each_word_shell_escaped"
                      , letValue = "map(l:expanded_args, 'shellescape(v:val)')"
                      }
                  , LetStatement
                      { letLexpr = "l:joined"
                      , letValue = "join(l:each_word_shell_escaped)"
                      }
                  , GenericStatement
                      "return substitute(l:joined, '<!!S!!>', ' ', 'g')"
                  ]
              }
          , FunctionDeclaration
              { functionBang = True
              , functionName = "ferret#private#post"
              , functionArguments = ArgumentList [ Argument "type" ]
              , functionAttributes = [ "abort" ]
              , functionBody =
                  [ GenericStatement "if has('autocmd')"
                  , GenericStatement "augroup FerretPostQF"
                  , GenericStatement "autocmd!"
                  , GenericStatement "augroup END"
                  , GenericStatement "endif"
                  , LetStatement
                      { letLexpr = "l:lastsearch "
                      , letValue = "get(g:, 'ferret_lastsearch', '')"
                      }
                  , LetStatement
                      { letLexpr = "l:qflist "
                      , letValue = "a:type == 'qf' ? getqflist() : getloclist(0)"
                      }
                  , LetStatement
                      { letLexpr = "l:tip "
                      , letValue = "' [see `:help ferret-quotes`]'"
                      }
                  , GenericStatement "if len(l:qflist) == 0"
                  , LetStatement
                      { letLexpr = "l:base "
                      , letValue =
                          "'No results for search pattern `' . l:lastsearch . '`'"
                      }
                  , GenericStatement
                      "if l:lastsearch =~ '\\v^([' . \"'\" . '\"])[^ \\1]+\\1$'"
                  , GenericStatement "call s:error(l:base . l:tip)"
                  , GenericStatement "else"
                  , GenericStatement "call s:error(l:base)"
                  , GenericStatement "endif"
                  , GenericStatement "else"
                  , LetStatement
                      { letLexpr = "l:invalid "
                      , letValue = "filter(copy(l:qflist), 'v:val.valid == 0')"
                      }
                  , GenericStatement "if len(l:invalid) == len(l:qflist)"
                  , GenericStatement "redraw!"
                  , GenericStatement "echohl ErrorMsg"
                  , GenericStatement "for l:item in l:invalid"
                  , GenericStatement "echomsg l:item.text"
                  , GenericStatement "endfor"
                  , GenericStatement "echohl NONE"
                  , LetStatement
                      { letLexpr = "l:base "
                      , letValue = "'Search for `' . l:lastsearch . '` failed'"
                      }
                  , LetStatement
                      { letLexpr = "l:suffix "
                      , letValue = "a:type == 'qf' && s:dispatch() ?"
                      }
                  , GenericStatement "\\ ' (run `:messages` to see details)' : ''"
                  , GenericStatement
                      "if l:lastsearch =~ '\\v^[' . \"'\" . '\"].+[^' . \"'\" . '\"]$'"
                  , GenericStatement "call s:error(l:base . l:tip . l:suffix)"
                  , GenericStatement "else"
                  , GenericStatement "call s:error(l:base . l:suffix)"
                  , GenericStatement "endif"
                  , GenericStatement "endif"
                  , GenericStatement "endif"
                  ]
              }
          , FunctionDeclaration
              { functionBang = True
              , functionName = "ferret#private#ack"
              , functionArguments = ArgumentList [ Argument "command" ]
              , functionAttributes = [ "abort" ]
              , functionBody =
                  [ LetStatement
                      { letLexpr = "l:command" , letValue = "s:parse(a:command)" }
                  , GenericStatement "call ferret#private#hlsearch()"
                  , GenericStatement "if empty(&grepprg)"
                  , GenericStatement "return"
                  , GenericStatement "endif"
                  , GenericStatement "if s:dispatch()"
                  , GenericStatement "if has('autocmd')"
                  , GenericStatement "augroup FerretPostQF"
                  , GenericStatement "autocmd!"
                  , GenericStatement
                      "autocmd QuickfixCmdPost cgetfile call ferret#private#post('qf')"
                  , GenericStatement "augroup END"
                  , GenericStatement "endif"
                  , LetStatement
                      { letLexpr = "l:original_makeprg" , letValue = "&l:makeprg" }
                  , LetStatement
                      { letLexpr = "l:original_errorformat"
                      , letValue = "&l:errorformat"
                      }
                  , GenericStatement "try"
                  , LetStatement
                      { letLexpr = "&l:makeprg"
                      , letValue = "&grepprg . ' ' . l:command"
                      }
                  , LetStatement
                      { letLexpr = "&l:errorformat" , letValue = "&grepformat" }
                  , GenericStatement "Make"
                  , GenericStatement "catch"
                  , GenericStatement "if has('autocmd')"
                  , GenericStatement "augroup! FerretPostQF"
                  , GenericStatement "endif"
                  , GenericStatement "finally"
                  , LetStatement
                      { letLexpr = "&l:makeprg" , letValue = "l:original_makeprg" }
                  , LetStatement
                      { letLexpr = "&l:errorformat"
                      , letValue = "l:original_errorformat"
                      }
                  , GenericStatement "endtry"
                  , GenericStatement "else"
                  , GenericStatement "cexpr system(&grepprg . ' ' . l:command)"
                  , GenericStatement "cwindow"
                  , GenericStatement "call ferret#private#post('qf')"
                  , GenericStatement "endif"
                  ]
              }
          , FunctionDeclaration
              { functionBang = True
              , functionName = "ferret#private#lack"
              , functionArguments = ArgumentList [ Argument "command" ]
              , functionAttributes = [ "abort" ]
              , functionBody =
                  [ LetStatement
                      { letLexpr = "l:command" , letValue = "s:parse(a:command)" }
                  , GenericStatement "call ferret#private#hlsearch()"
                  , GenericStatement "if empty(&grepprg)"
                  , GenericStatement "return"
                  , GenericStatement "endif"
                  , LexprStatement
                      { lexprBang = False
                      , lexprExpr = "system(&grepprg . ' ' . l:command)"
                      }
                  , LwindowStatement { lwindowHeight = Nothing }
                  , GenericStatement "call ferret#private#post('location')"
                  ]
              }
          , FunctionDeclaration
              { functionBang = True
              , functionName = "ferret#private#hlsearch"
              , functionArguments = ArgumentList []
              , functionAttributes = [ "abort" ]
              , functionBody =
                  [ GenericStatement "if has('extra_search')"
                  , Empty
                  , LetStatement
                      { letLexpr = "l:hlsearch"
                      , letValue = "get(g:, 'FerretHlsearch', &hlsearch)"
                      }
                  , GenericStatement "if l:hlsearch"
                  , LetStatement
                      { letLexpr = "@/" , letValue = "g:ferret_lastsearch" }
                  , GenericStatement
                      "call feedkeys(\":let &hlsearch=1 | echo \\<CR>\", 'n')"
                  , GenericStatement "endif"
                  , GenericStatement "endif"
                  ]
              }
          , FunctionDeclaration
              { functionBang = True
              , functionName = "ferret#private#acks"
              , functionArguments = ArgumentList [ Argument "command" ]
              , functionAttributes = [ "abort" ]
              , functionBody =
                  [ GenericStatement
                      "if match(a:command, '\\v^/.+/.*/$') == -1 \" crude sanity check"
                  , GenericStatement
                      "echoerr 'Ferret: Expected a substitution expression (/foo/bar/); got: ' . a:command"
                  , GenericStatement "return"
                  , GenericStatement "endif"
                  , LetStatement
                      { letLexpr = "l:filenames" , letValue = "ferret#private#qargs()" }
                  , GenericStatement "if l:filenames ==# ''"
                  , GenericStatement
                      "echoerr 'Ferret: Quickfix filenames must be present, but there are none'"
                  , GenericStatement "return"
                  , GenericStatement "endif"
                  , GenericStatement "execute 'args' l:filenames"
                  , GenericStatement
                      "if v:version > 703 || v:version == 703 && has('patch438')"
                  , GenericStatement
                      "silent doautocmd <nomodeline> User FerretWillWrite"
                  , GenericStatement "else"
                  , GenericStatement "silent doautocmd User FerretWillWrite"
                  , GenericStatement "endif"
                  , GenericStatement
                      "execute 'argdo' '%s' . a:command . 'ge | update'"
                  , GenericStatement
                      "if v:version > 703 || v:version == 703 && has('patch438')"
                  , GenericStatement
                      "silent doautocmd <nomodeline> User FerretDidWrite"
                  , GenericStatement "else"
                  , GenericStatement "silent doautocmd User FerretDidWrite"
                  , GenericStatement "endif"
                  ]
              }
          , FunctionDeclaration
              { functionBang = True
              , functionName = "ferret#private#qargs"
              , functionArguments = ArgumentList []
              , functionAttributes = [ "abort" ]
              , functionBody =
                  [ LetStatement { letLexpr = "l:buffer_numbers" , letValue = "{}" }
                  , GenericStatement "for l:item in getqflist()"
                  , LetStatement
                      { letLexpr = "l:buffer_numbers[l:item['bufnr']]"
                      , letValue = "bufname(l:item['bufnr'])"
                      }
                  , GenericStatement "endfor"
                  , GenericStatement
                      "return join(map(values(l:buffer_numbers), 'fnameescape(v:val)'))"
                  ]
              }
          , FunctionDeclaration
              { functionBang = True
              , functionName = "ferret#private#qf_delete"
              , functionArguments = ArgumentList []
              , functionAttributes = [ "range" ]
              , functionBody =
                  [ GenericStatement "call s:delete(a:firstline, a:lastline)" ]
              }
          , FunctionDeclaration
              { functionBang = True
              , functionName = "ferret#private#qf_delete_motion"
              , functionArguments =
                  ArgumentList [ Argument "type" , Argument "..." ]
              , functionAttributes = []
              , functionBody =
                  [ LetStatement
                      { letLexpr = "l:selection" , letValue = "&selection" }
                  , LetStatement
                      { letLexpr = "&selection" , letValue = "'inclusive'" }
                  , LetStatement
                      { letLexpr = "l:firstline" , letValue = "line(\"'[\")" }
                  , LetStatement
                      { letLexpr = "l:lastline" , letValue = "line(\"']\")" }
                  , GenericStatement "call s:delete(l:firstline, l:lastline)"
                  , LetStatement
                      { letLexpr = "&selection" , letValue = "l:selection" }
                  ]
              }
          ]
      , Empty
      ]
  , OptionsAnnotation
  , OptionAnnotation "g:FerretDispatch" "boolean" (Just "1")
  , Paragraph
      [ Plaintext "Controls"
      , Whitespace
      , Plaintext "whether"
      , Whitespace
      , Plaintext "to"
      , Whitespace
      , Plaintext "use"
      , Whitespace
      , Plaintext "vim-dispatch"
      , Whitespace
      , Plaintext "(and"
      , Whitespace
      , Plaintext "specifically,"
      , Whitespace
      , Link ":Make"
      , Plaintext ")"
      , Whitespace
      , Plaintext "to"
      , Whitespace
      , Plaintext "run"
      , Whitespace
      , Link ":Ack"
      , Whitespace
      , Plaintext "searches"
      , Whitespace
      , Plaintext "asynchronously,"
      , Whitespace
      , Plaintext "when"
      , Whitespace
      , Plaintext "available."
      , Whitespace
      , Plaintext "To"
      , Whitespace
      , Plaintext "prevent"
      , Whitespace
      , Plaintext "vim-dispatch"
      , Whitespace
      , Plaintext "from"
      , Whitespace
      , Plaintext "being"
      , Whitespace
      , Plaintext "used,"
      , Whitespace
      , Plaintext "set"
      , Whitespace
      , Plaintext "to"
      , Whitespace
      , Plaintext "0:"
      ]
  , Fenced [ "let g:FerretDispatch=0" ]
  , OptionAnnotation "g:FerretHlsearch" "boolean" Nothing
  , Paragraph
      [ Plaintext "Controls"
      , Whitespace
      , Plaintext "whether"
      , Whitespace
      , Plaintext "Ferret"
      , Whitespace
      , Plaintext "should"
      , Whitespace
      , Plaintext "attempt"
      , Whitespace
      , Plaintext "to"
      , Whitespace
      , Plaintext "highlight"
      , Whitespace
      , Plaintext "the"
      , Whitespace
      , Plaintext "search"
      , Whitespace
      , Plaintext "pattern"
      , Whitespace
      , Plaintext "when"
      , Whitespace
      , Plaintext "running"
      , Whitespace
      , Link ":Ack"
      , Whitespace
      , Plaintext "or"
      , Whitespace
      , Link ":Lack"
      , Plaintext "."
      , Whitespace
      , Plaintext "If"
      , Whitespace
      , Plaintext "left"
      , Whitespace
      , Plaintext "unset,"
      , Whitespace
      , Plaintext "Ferret"
      , Whitespace
      , Plaintext "will"
      , Whitespace
      , Plaintext "respect"
      , Whitespace
      , Plaintext "the"
      , Whitespace
      , Plaintext "current"
      , Whitespace
      , Plaintext "'hlsearch'"
      , Whitespace
      , Plaintext "setting."
      , Whitespace
      , Plaintext "To"
      , Whitespace
      , Plaintext "force"
      , Whitespace
      , Plaintext "highlighting"
      , Whitespace
      , Plaintext "on"
      , Whitespace
      , Plaintext "or"
      , Whitespace
      , Plaintext "off"
      , Whitespace
      , Plaintext "irrespective"
      , Whitespace
      , Plaintext "of"
      , Whitespace
      , Plaintext "'hlsearch',"
      , Whitespace
      , Plaintext "set"
      , Whitespace
      , Link "g:FerretHlsearch"
      , Whitespace
      , Plaintext "to"
      , Whitespace
      , Plaintext "1"
      , Whitespace
      , Plaintext "(on)"
      , Whitespace
      , Plaintext "or"
      , Whitespace
      , Plaintext "0"
      , Whitespace
      , Plaintext "(off):"
      ]
  , Fenced [ "let g:FerretHlsearch=0" ]
  ]
